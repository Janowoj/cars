# Installed:
@reduxjs/toolkit
react-redux
bulma

# Compenents:
CarForm
CarSearch
CarList
CarValue

# State

If components are going to try to change the state by dispatching action objects, they are going to fetch state by making use of thes useSelector hook and using bunch of JSX expressions to render the state values.

# Redux store design

1. Identify what state exits in the app:
name (string), 
cost (number), 
searchTerm (string),
cars ( array of {id, name, cost}),

// derived state (values that we can calculate using some existing state):

totalCost (number),
matchedCars (???),


2. Identify how that state changes over time

name (string) -  changeName (user types in the name field)

cost (number) - changeCost

searchTerm (string) - changeSearchTerm

cars ( array of {id, name, cost}) - addCar, removeCar etc.

// for each of these STATE VALUES we can create a different MINI REDUCER function inside one of our different SLICE files 

// Redux Toolkit is going to automatically make different ACTION CREATORS for each of these mini reducers

3. Group together common pieces of state (many solutions are possible):

// State related to adding cars (Slice #1):
name (string),
cost (number)

// State related to the list of cars (Slice #2):
searchTerm (string),
cars ( array of {id, name, cost}),


4. Create a slice for each group of state

Form Slice: 

changeName.js
changeCost.js

Cars Slice:

changeTerm.js
addCar.js
removeCar.js

 # Maintaining a collection of the slices

 Reducers of the carSlice needs to get access to the state values of the formSlice (name and cost).

 But is NOT POSSIBLE to import the state values from one slice to another slice!

 We have to assume, that whenever we call addCar, the ACTION PAYLOAD property is going to be an OBJECT, that is going to CONTAIN THE NAME AND COST VALUES.

We don't need to use --> id: Math.random()

...because we are going to use the id value that is going to be generated by the Redux Toolkit: --> nanoid() function.

# Form Values to update the state

We are going to use the useSelector hook to get access to the state values of the formSlice (name and cost).

In the CarForm component we are going to use the useDispatch hook to get access to the dispatch function.

# Dispatching during the form submission

Create onSubmit handler function in the CarForm component.

Add a button to the CarForm component.

Use dispatch function to dispatch the addCar action creator.

Call action creator passing in the name and cost values as the action payload object.

Display a list of cars in the CarList component.

# Weird double keys

Inside the CarList component we are going to use the useSelector hook to get access to the state values of the carsSlice (cars).

const cars  = useSelector(state => {
        return state.cars.cars;
    });

We are going to use the map function to iterate over the cars array and display a list of cars.

Repeating property names can cause engineers to think that there is some kind of a bug in the app.

Fixing the double keys:

const cars = useSelector(state => {
    return state.cars.data;
});

# Form reset on submission

Inside the haandleSubmit function we can use mutliple dispatch calls:

dispatch(changeCost(0));
dispatch(changeName(''));

Mutliple dispatch calls are the sign that we need the 'extraReducers' property in the carSlice.

# Extra reducers

We can use the 'extraReducers' property to listen to the action creators that are defined in the other slices:

extraReducers(builder) {
        builder.addCase(addCar, (state, action) => {
            state.name = '';
            state.cost = 0;
        });
    }

# Derived state

data and searchTerm are the two pieces of state that we can use to calculate the filteredCars array.

